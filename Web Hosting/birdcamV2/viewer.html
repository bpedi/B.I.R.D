<!DOCTYPE html>
<html>
<head>
    <title>Camera Viewer - Automated</title>
    <style>
        body { font-family: 'Inter', sans-serif; margin: 20px; background-color: #f0f0f0; display: flex; justify-content: center; align-items: center; min-height: 90vh; }
        .container { background-color: white; padding: 30px; border-radius: 12px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); text-align: center; max-width: 400px; width: 100%; }
        h1 { color: #333; margin-bottom: 20px; font-size: 1.8em; }
        #remoteVideo { border: 2px solid #ddd; width: 100%; max-width: 320px; height: 240px; background-color: #000; border-radius: 8px; margin-bottom: 20px; display: block; margin-left: auto; margin-right: auto; }
        button {
            padding: 12px 25px;
            font-size: 1.1em;
            cursor: pointer;
            background-color: #007bff; /* Blue for viewer button */
            color: white;
            border: none;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            transition: background-color 0.3s ease, transform 0.2s ease;
            margin-top: 10px;
        }
        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        .status { margin-top: 20px; font-style: italic; color: #555; font-size: 0.9em; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Camera Viewer (Auto-Connect)</h1>
        <video id="remoteVideo" autoplay playsinline></video><br>
        <button id="playRemoteVideo">Play Remote Video</button>
        <div id="status" class="status">Status: Initializing...</div>
    </div>

    <script>
        const remoteVideo = document.getElementById('remoteVideo');
        const playButton = document.getElementById('playRemoteVideo');
        const statusDiv = document.getElementById('status');

        let pc; // PeerConnection
        let signalingSocket; // WebSocket for signaling

        // IMPORTANT: Replace 'YOUR_COMPUTERS_IP_ADDRESS' with your actual local IP (e.g., 192.168.1.100)
        // Ensure this matches the IP your phone will use to access the server.
        const SIGNALING_SERVER_IP = '192.168.1.163'; 
        const SIGNALING_SERVER_PORT = 8001; // This is the port for the WebSocket server

        // Use 'wss://' because your HTML page is served over HTTPS
        const signalingServerUrl = `wss://${SIGNALING_SERVER_IP}:${SIGNALING_SERVER_PORT}`;

        const configuration = {
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        };

        function logStatus(msg) {
            console.log(`VIEWER: ${msg}`);
            statusDiv.textContent = `Status: ${msg}`;
        }

        // Initialize WebSocket connection
        function initSignalingSocket() {
            if (signalingSocket && (signalingSocket.readyState === WebSocket.OPEN || signalingSocket.readyState === WebSocket.CONNECTING)) {
                logStatus("WebSocket already connected or connecting.");
                return;
            }

            signalingSocket = new WebSocket(signalingServerUrl);

            signalingSocket.onopen = () => {
                logStatus("Connected to signaling server. Signaling readiness to host...");
                // Viewer signals readiness immediately upon connecting to WS server
                signalingSocket.send(JSON.stringify({ type: 'viewer_ready', from: 'viewer' }));
            };

            signalingSocket.onmessage = async (event) => {
                try {
                    const message = JSON.parse(event.data);
                    // Ignore messages sent by self (if 'from' field is added and matches)
                    if (message.from === 'viewer') return;

                    logStatus(`Received message type: ${message.type}`);

                    // Ensure PC is ready before processing most messages
                    if (!pc || pc.signalingState === 'closed') {
                        if (message.type === 'offer') { // Only re-setup for offer if closed
                            logStatus("PC was closed. Re-initializing for new offer.");
                            setupPeerConnection();
                        } else if (message.type !== 'viewer_ready') { // For other messages, if pc is closed, maybe ignore
                            logStatus(`PC is closed. Ignoring message type: ${message.type}`);
                            return;
                        }
                    }

                    switch (message.type) {
                        case 'offer':
                            // Defensive check: ensure PC is in a state to accept an offer
                            if (pc.signalingState !== 'stable' && pc.signalingState !== 'have-remote-offer') {
                                logStatus(`PC in unexpected state ${pc.signalingState} before processing offer. Resetting PC.`);
                                setupPeerConnection(); // Reset to a clean 'stable' state
                            }
                            logStatus("Received offer. Setting remote description and creating answer...");
                            try {
                                // Reconstruct RTCSessionDescription from plain object
                                await pc.setRemoteDescription(new RTCSessionDescription(message.sdp));
                                const answer = await pc.createAnswer();
                                await pc.setLocalDescription(answer);
                                // Serialize the RTCSessionDescription object to a plain JSON object
                                signalingSocket.send(JSON.stringify({ type: 'answer', sdp: pc.localDescription.toJSON(), from: 'viewer' }));
                                logStatus("Answer sent to host.");
                            } catch (error) {
                                console.error("VIEWER: Error processing offer or creating answer:", error);
                                logStatus(`Error with offer/answer: ${error.message}. Re-signaling readiness.`);
                                setupPeerConnection(); // Reset PC
                                if (signalingSocket.readyState === WebSocket.OPEN) {
                                    signalingSocket.send(JSON.stringify({ type: 'viewer_ready', from: 'viewer' })); // Ask for offer again
                                }
                            }
                            break;
                        case 'candidate':
                            if (message.candidate && pc && pc.signalingState !== 'closed') {
                                logStatus("Received ICE candidate from host. Adding it.");
                                try {
                                    // Reconstruct RTCIceCandidate from plain object
                                    await pc.addIceCandidate(new RTCIceCandidate(message.candidate));
                                } catch (error) {
                                    if (!error.message.includes("candidate can no longer be gathered") && !error.message.includes("The RTCPeerConnection's signalingState is 'closed'")) {
                                        console.warn("VIEWER: Error adding received ICE candidate:", error);
                                    }
                                }
                            }
                            break;
                    }
                } catch (error) {
                    console.error("VIEWER: Error parsing or handling WebSocket message:", error);
                }
            };

            signalingSocket.onerror = (error) => {
                console.error("VIEWER: WebSocket Error:", error);
                logStatus("Error connecting to signaling server. Check console.");
            };

            signalingSocket.onclose = (event) => {
                console.log("VIEWER: WebSocket closed:", event);
                logStatus(`Disconnected from signaling server. Code: ${event.code}, Reason: ${event.reason}. Reconnecting in 3s...`);
                // Simple reconnect logic
                setTimeout(initSignalingSocket, 3000);
            };
        }

        function setupPeerConnection() {
            if (pc && pc.connectionState !== 'closed') {
                pc.close();
            }
            pc = new RTCPeerConnection(configuration);
            logStatus("PeerConnection (re)initialized.");

            pc.ontrack = event => {
                logStatus("Track received! Attempting to display stream...");
                console.log("VIEWER DEBUG: event.streams:", event.streams);
                console.log("VIEWER DEBUG: event.track:", event.track);

                if (event.streams && event.streams[0]) {
                    console.log("VIEWER DEBUG: Entering primary stream handling path.");
                    if (remoteVideo.srcObject !== event.streams[0]) {
                        remoteVideo.srcObject = event.streams[0];
                        logStatus("Video stream attached to video element.");
                    } else {
                        console.log("VIEWER DEBUG: Stream already attached, skipping redundant assignment.");
                    }
                } else {
                    console.log("VIEWER DEBUG: Entering fallback track handling path (event.streams empty/null).");
                    let inboundStream = new MediaStream();
                    inboundStream.addTrack(event.track);
                    remoteVideo.srcObject = inboundStream;
                    logStatus("Video track attached to video element (fallback).");
                }

                if (remoteVideo.srcObject) {
                    console.log("VIEWER DEBUG: remoteVideo.srcObject IS set to a MediaStream.");
                    // Attempt to play automatically here, but user interaction might still be needed
                    remoteVideo.play().catch(e => console.warn("VIEWER: Autoplay blocked after stream attachment. User intervention needed.", e));
                } else {
                    console.log("VIEWER DEBUG: WARNING! remoteVideo.srcObject IS NOT set after ontrack event.");
                }
            };

            pc.onicecandidate = event => {
                if (event.candidate) {
                    logStatus("Sending ICE candidate to host.");
                    // Serialize the RTCIceCandidate object to a plain JSON object
                    signalingSocket.send(JSON.stringify({ type: 'candidate', candidate: event.candidate.toJSON(), from: 'viewer' }));
                }
            };

            pc.onconnectionstatechange = () => {
                logStatus(`Connection state: ${pc.connectionState}`);
                if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
                    logStatus("Connection failed or lost. Re-initializing and requesting new offer.");
                    // Aggressively try to reconnect by resetting and signaling readiness.
                    // setupPeerConnection();
                    // if (signalingSocket.readyState === WebSocket.OPEN) {
                    //     signalingSocket.send(JSON.stringify({ type: 'viewer_ready', from: 'viewer' }));
                    // }
                } else if (pc.connectionState === "connected") {
                    logStatus("Connected to Host and streaming! 🎉");
                }
            };
        }

        playButton.onclick = () => {
            if (remoteVideo.srcObject) {
                remoteVideo.play().catch(e => console.error("VIEWER: Error playing video after button click:", e));
                logStatus("Attempting to play video...");
            } else {
                logStatus("No stream attached to play yet. Waiting for host connection.");
            }
        };

        window.onload = () => {
            logStatus("Page loaded. Initializing PeerConnection and WebSocket connection...");
            setupPeerConnection(); // Initialize PC first
            initSignalingSocket(); // Then connect to WebSocket
        };

        // Optional: Clean up WebSocket and PeerConnection when the window is closed
        window.addEventListener('beforeunload', () => {
            if (signalingSocket && signalingSocket.readyState === WebSocket.OPEN) {
                signalingSocket.close();
            }
            if (pc) {
                pc.close();
            }
        });
    </script>
</body>
</html>
